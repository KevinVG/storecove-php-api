<?php
/**
 * Invoice
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Storecove API
 *
 * Storecove API
 *
 * OpenAPI spec version: 2.0.1
 * Contact: apisupport@storecove.nl
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * Invoice Class Doc Comment
 *
 * @category Class
 * @description The invoice to send
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Invoice implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'Invoice';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'document_currency_code' => '\Swagger\Client\Model\CurrencyCode',
        'invoice_number' => 'string',
        'issue_date' => 'string',
        'vat_reverse_charge' => 'bool',
        'accounting_customer_party' => '\Swagger\Client\Model\AccountingCustomerParty',
        'buyer_customer_party' => '\Swagger\Client\Model\BuyerCustomerParty',
        'note' => 'string',
        'delivery' => '\Swagger\Client\Model\Delivery',
        'allowance_charges' => '\Swagger\Client\Model\AllowanceCharge[]',
        'invoice_lines' => '\Swagger\Client\Model\InvoiceLine[]',
        'accounting_cost' => 'string',
        'accounting_cost_code' => '\Swagger\Client\Model\AccountingCostCode',
        'due_date' => 'string',
        'invoice_type' => 'string',
        'tax_point_date' => 'string',
        'buyer_reference' => 'string',
        'invoice_period' => 'string',
        'order_reference' => 'string',
        'sales_order_id' => 'string',
        'billing_reference' => 'string',
        'contract_document_reference' => 'string',
        'project_reference' => 'string',
        'payment_means_iban' => 'string',
        'payment_means_code' => 'string',
        'payment_means_payment_id' => 'string',
        'amount_including_vat' => 'float'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'document_currency_code' => null,
        'invoice_number' => null,
        'issue_date' => null,
        'vat_reverse_charge' => null,
        'accounting_customer_party' => null,
        'buyer_customer_party' => null,
        'note' => null,
        'delivery' => null,
        'allowance_charges' => null,
        'invoice_lines' => null,
        'accounting_cost' => null,
        'accounting_cost_code' => null,
        'due_date' => null,
        'invoice_type' => null,
        'tax_point_date' => null,
        'buyer_reference' => null,
        'invoice_period' => null,
        'order_reference' => null,
        'sales_order_id' => null,
        'billing_reference' => null,
        'contract_document_reference' => null,
        'project_reference' => null,
        'payment_means_iban' => null,
        'payment_means_code' => null,
        'payment_means_payment_id' => null,
        'amount_including_vat' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'document_currency_code' => 'documentCurrencyCode',
        'invoice_number' => 'invoiceNumber',
        'issue_date' => 'issueDate',
        'vat_reverse_charge' => 'vatReverseCharge',
        'accounting_customer_party' => 'accountingCustomerParty',
        'buyer_customer_party' => 'buyerCustomerParty',
        'note' => 'note',
        'delivery' => 'delivery',
        'allowance_charges' => 'allowanceCharges',
        'invoice_lines' => 'invoiceLines',
        'accounting_cost' => 'accountingCost',
        'accounting_cost_code' => 'accountingCostCode',
        'due_date' => 'dueDate',
        'invoice_type' => 'invoiceType',
        'tax_point_date' => 'taxPointDate',
        'buyer_reference' => 'buyerReference',
        'invoice_period' => 'invoicePeriod',
        'order_reference' => 'orderReference',
        'sales_order_id' => 'salesOrderId',
        'billing_reference' => 'billingReference',
        'contract_document_reference' => 'contractDocumentReference',
        'project_reference' => 'projectReference',
        'payment_means_iban' => 'paymentMeansIban',
        'payment_means_code' => 'paymentMeansCode',
        'payment_means_payment_id' => 'paymentMeansPaymentId',
        'amount_including_vat' => 'amountIncludingVat'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'document_currency_code' => 'setDocumentCurrencyCode',
        'invoice_number' => 'setInvoiceNumber',
        'issue_date' => 'setIssueDate',
        'vat_reverse_charge' => 'setVatReverseCharge',
        'accounting_customer_party' => 'setAccountingCustomerParty',
        'buyer_customer_party' => 'setBuyerCustomerParty',
        'note' => 'setNote',
        'delivery' => 'setDelivery',
        'allowance_charges' => 'setAllowanceCharges',
        'invoice_lines' => 'setInvoiceLines',
        'accounting_cost' => 'setAccountingCost',
        'accounting_cost_code' => 'setAccountingCostCode',
        'due_date' => 'setDueDate',
        'invoice_type' => 'setInvoiceType',
        'tax_point_date' => 'setTaxPointDate',
        'buyer_reference' => 'setBuyerReference',
        'invoice_period' => 'setInvoicePeriod',
        'order_reference' => 'setOrderReference',
        'sales_order_id' => 'setSalesOrderId',
        'billing_reference' => 'setBillingReference',
        'contract_document_reference' => 'setContractDocumentReference',
        'project_reference' => 'setProjectReference',
        'payment_means_iban' => 'setPaymentMeansIban',
        'payment_means_code' => 'setPaymentMeansCode',
        'payment_means_payment_id' => 'setPaymentMeansPaymentId',
        'amount_including_vat' => 'setAmountIncludingVat'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'document_currency_code' => 'getDocumentCurrencyCode',
        'invoice_number' => 'getInvoiceNumber',
        'issue_date' => 'getIssueDate',
        'vat_reverse_charge' => 'getVatReverseCharge',
        'accounting_customer_party' => 'getAccountingCustomerParty',
        'buyer_customer_party' => 'getBuyerCustomerParty',
        'note' => 'getNote',
        'delivery' => 'getDelivery',
        'allowance_charges' => 'getAllowanceCharges',
        'invoice_lines' => 'getInvoiceLines',
        'accounting_cost' => 'getAccountingCost',
        'accounting_cost_code' => 'getAccountingCostCode',
        'due_date' => 'getDueDate',
        'invoice_type' => 'getInvoiceType',
        'tax_point_date' => 'getTaxPointDate',
        'buyer_reference' => 'getBuyerReference',
        'invoice_period' => 'getInvoicePeriod',
        'order_reference' => 'getOrderReference',
        'sales_order_id' => 'getSalesOrderId',
        'billing_reference' => 'getBillingReference',
        'contract_document_reference' => 'getContractDocumentReference',
        'project_reference' => 'getProjectReference',
        'payment_means_iban' => 'getPaymentMeansIban',
        'payment_means_code' => 'getPaymentMeansCode',
        'payment_means_payment_id' => 'getPaymentMeansPaymentId',
        'amount_including_vat' => 'getAmountIncludingVat'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const INVOICE_TYPE__380 = '380';
    const INVOICE_TYPE__381 = '381';
    const INVOICE_TYPE__384 = '384';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getInvoiceTypeAllowableValues()
    {
        return [
            self::INVOICE_TYPE__380,
            self::INVOICE_TYPE__381,
            self::INVOICE_TYPE__384,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['document_currency_code'] = isset($data['document_currency_code']) ? $data['document_currency_code'] : null;
        $this->container['invoice_number'] = isset($data['invoice_number']) ? $data['invoice_number'] : null;
        $this->container['issue_date'] = isset($data['issue_date']) ? $data['issue_date'] : null;
        $this->container['vat_reverse_charge'] = isset($data['vat_reverse_charge']) ? $data['vat_reverse_charge'] : false;
        $this->container['accounting_customer_party'] = isset($data['accounting_customer_party']) ? $data['accounting_customer_party'] : null;
        $this->container['buyer_customer_party'] = isset($data['buyer_customer_party']) ? $data['buyer_customer_party'] : null;
        $this->container['note'] = isset($data['note']) ? $data['note'] : null;
        $this->container['delivery'] = isset($data['delivery']) ? $data['delivery'] : null;
        $this->container['allowance_charges'] = isset($data['allowance_charges']) ? $data['allowance_charges'] : null;
        $this->container['invoice_lines'] = isset($data['invoice_lines']) ? $data['invoice_lines'] : null;
        $this->container['accounting_cost'] = isset($data['accounting_cost']) ? $data['accounting_cost'] : null;
        $this->container['accounting_cost_code'] = isset($data['accounting_cost_code']) ? $data['accounting_cost_code'] : null;
        $this->container['due_date'] = isset($data['due_date']) ? $data['due_date'] : null;
        $this->container['invoice_type'] = isset($data['invoice_type']) ? $data['invoice_type'] : '380';
        $this->container['tax_point_date'] = isset($data['tax_point_date']) ? $data['tax_point_date'] : null;
        $this->container['buyer_reference'] = isset($data['buyer_reference']) ? $data['buyer_reference'] : null;
        $this->container['invoice_period'] = isset($data['invoice_period']) ? $data['invoice_period'] : null;
        $this->container['order_reference'] = isset($data['order_reference']) ? $data['order_reference'] : null;
        $this->container['sales_order_id'] = isset($data['sales_order_id']) ? $data['sales_order_id'] : null;
        $this->container['billing_reference'] = isset($data['billing_reference']) ? $data['billing_reference'] : null;
        $this->container['contract_document_reference'] = isset($data['contract_document_reference']) ? $data['contract_document_reference'] : null;
        $this->container['project_reference'] = isset($data['project_reference']) ? $data['project_reference'] : null;
        $this->container['payment_means_iban'] = isset($data['payment_means_iban']) ? $data['payment_means_iban'] : null;
        $this->container['payment_means_code'] = isset($data['payment_means_code']) ? $data['payment_means_code'] : null;
        $this->container['payment_means_payment_id'] = isset($data['payment_means_payment_id']) ? $data['payment_means_payment_id'] : null;
        $this->container['amount_including_vat'] = isset($data['amount_including_vat']) ? $data['amount_including_vat'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['invoice_number'] === null) {
            $invalidProperties[] = "'invoice_number' can't be null";
        }
        if ((strlen($this->container['invoice_number']) < 1)) {
            $invalidProperties[] = "invalid value for 'invoice_number', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['issue_date'] === null) {
            $invalidProperties[] = "'issue_date' can't be null";
        }
        if (!preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/", $this->container['issue_date'])) {
            $invalidProperties[] = "invalid value for 'issue_date', must be conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.";
        }

        if ($this->container['accounting_customer_party'] === null) {
            $invalidProperties[] = "'accounting_customer_party' can't be null";
        }
        if ($this->container['invoice_lines'] === null) {
            $invalidProperties[] = "'invoice_lines' can't be null";
        }
        if (!is_null($this->container['accounting_cost']) && (strlen($this->container['accounting_cost']) < 1)) {
            $invalidProperties[] = "invalid value for 'accounting_cost', the character length must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['due_date']) && !preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/", $this->container['due_date'])) {
            $invalidProperties[] = "invalid value for 'due_date', must be conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.";
        }

        $allowedValues = $this->getInvoiceTypeAllowableValues();
        if (!in_array($this->container['invoice_type'], $allowedValues)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'invoice_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['tax_point_date']) && !preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/", $this->container['tax_point_date'])) {
            $invalidProperties[] = "invalid value for 'tax_point_date', must be conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.";
        }

        if (!is_null($this->container['invoice_period']) && !preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2} - [0-9]{4}-[0-9]{2}-[0-9]{2}$/", $this->container['invoice_period'])) {
            $invalidProperties[] = "invalid value for 'invoice_period', must be conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2} - [0-9]{4}-[0-9]{2}-[0-9]{2}$/.";
        }

        if ($this->container['amount_including_vat'] === null) {
            $invalidProperties[] = "'amount_including_vat' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        if ($this->container['invoice_number'] === null) {
            return false;
        }
        if (strlen($this->container['invoice_number']) < 1) {
            return false;
        }
        if ($this->container['issue_date'] === null) {
            return false;
        }
        if (!preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/", $this->container['issue_date'])) {
            return false;
        }
        if ($this->container['accounting_customer_party'] === null) {
            return false;
        }
        if ($this->container['invoice_lines'] === null) {
            return false;
        }
        if (strlen($this->container['accounting_cost']) < 1) {
            return false;
        }
        if (!preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/", $this->container['due_date'])) {
            return false;
        }
        $allowedValues = $this->getInvoiceTypeAllowableValues();
        if (!in_array($this->container['invoice_type'], $allowedValues)) {
            return false;
        }
        if (!preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/", $this->container['tax_point_date'])) {
            return false;
        }
        if (!preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2} - [0-9]{4}-[0-9]{2}-[0-9]{2}$/", $this->container['invoice_period'])) {
            return false;
        }
        if ($this->container['amount_including_vat'] === null) {
            return false;
        }
        return true;
    }


    /**
     * Gets document_currency_code
     *
     * @return \Swagger\Client\Model\CurrencyCode
     */
    public function getDocumentCurrencyCode()
    {
        return $this->container['document_currency_code'];
    }

    /**
     * Sets document_currency_code
     *
     * @param \Swagger\Client\Model\CurrencyCode $document_currency_code The documentCurrencyCode is the currency for the entire invoice. We currently do not support invoices in multiple currencies. If left out, will default to EUR
     *
     * @return $this
     */
    public function setDocumentCurrencyCode($document_currency_code)
    {
        $this->container['document_currency_code'] = $document_currency_code;

        return $this;
    }

    /**
     * Gets invoice_number
     *
     * @return string
     */
    public function getInvoiceNumber()
    {
        return $this->container['invoice_number'];
    }

    /**
     * Sets invoice_number
     *
     * @param string $invoice_number The invoice number you assigned to the invoice. The invoiceNumber should be unique for the legalEntityId and year of the issueDate. This means invoice numbers can be reused in different years, as is customary in some countries.
     *
     * @return $this
     */
    public function setInvoiceNumber($invoice_number)
    {

        if ((strlen($invoice_number) < 1)) {
            throw new \InvalidArgumentException('invalid length for $invoice_number when calling Invoice., must be bigger than or equal to 1.');
        }

        $this->container['invoice_number'] = $invoice_number;

        return $this;
    }

    /**
     * Gets issue_date
     *
     * @return string
     */
    public function getIssueDate()
    {
        return $this->container['issue_date'];
    }

    /**
     * Sets issue_date
     *
     * @param string $issue_date Format: yyyy-mm-dd.
     *
     * @return $this
     */
    public function setIssueDate($issue_date)
    {

        if ((!preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/", $issue_date))) {
            throw new \InvalidArgumentException("invalid value for $issue_date when calling Invoice., must conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.");
        }

        $this->container['issue_date'] = $issue_date;

        return $this;
    }

    /**
     * Gets vat_reverse_charge
     *
     * @return bool
     */
    public function getVatReverseCharge()
    {
        return $this->container['vat_reverse_charge'];
    }

    /**
     * Sets vat_reverse_charge
     *
     * @param bool $vat_reverse_charge Whether or not the invoice is reverse charged
     *
     * @return $this
     */
    public function setVatReverseCharge($vat_reverse_charge)
    {
        $this->container['vat_reverse_charge'] = $vat_reverse_charge;

        return $this;
    }

    /**
     * Gets accounting_customer_party
     *
     * @return \Swagger\Client\Model\AccountingCustomerParty
     */
    public function getAccountingCustomerParty()
    {
        return $this->container['accounting_customer_party'];
    }

    /**
     * Sets accounting_customer_party
     *
     * @param \Swagger\Client\Model\AccountingCustomerParty $accounting_customer_party The party the invoice is sent to.
     *
     * @return $this
     */
    public function setAccountingCustomerParty($accounting_customer_party)
    {
        $this->container['accounting_customer_party'] = $accounting_customer_party;

        return $this;
    }

    /**
     * Gets buyer_customer_party
     *
     * @return \Swagger\Client\Model\BuyerCustomerParty
     */
    public function getBuyerCustomerParty()
    {
        return $this->container['buyer_customer_party'];
    }

    /**
     * Sets buyer_customer_party
     *
     * @param \Swagger\Client\Model\BuyerCustomerParty $buyer_customer_party The buyer party.
     *
     * @return $this
     */
    public function setBuyerCustomerParty($buyer_customer_party)
    {
        $this->container['buyer_customer_party'] = $buyer_customer_party;

        return $this;
    }

    /**
     * Gets note
     *
     * @return string
     */
    public function getNote()
    {
        return $this->container['note'];
    }

    /**
     * Sets note
     *
     * @param string $note A note to add to the invoice
     *
     * @return $this
     */
    public function setNote($note)
    {
        $this->container['note'] = $note;

        return $this;
    }

    /**
     * Gets delivery
     *
     * @return \Swagger\Client\Model\Delivery
     */
    public function getDelivery()
    {
        return $this->container['delivery'];
    }

    /**
     * Sets delivery
     *
     * @param \Swagger\Client\Model\Delivery $delivery The delivery of the invoice.
     *
     * @return $this
     */
    public function setDelivery($delivery)
    {
        $this->container['delivery'] = $delivery;

        return $this;
    }

    /**
     * Gets allowance_charges
     *
     * @return \Swagger\Client\Model\AllowanceCharge[]
     */
    public function getAllowanceCharges()
    {
        return $this->container['allowance_charges'];
    }

    /**
     * Sets allowance_charges
     *
     * @param \Swagger\Client\Model\AllowanceCharge[] $allowance_charges An array of allowance charges.
     *
     * @return $this
     */
    public function setAllowanceCharges($allowance_charges)
    {
        $this->container['allowance_charges'] = $allowance_charges;

        return $this;
    }

    /**
     * Gets invoice_lines
     *
     * @return \Swagger\Client\Model\InvoiceLine[]
     */
    public function getInvoiceLines()
    {
        return $this->container['invoice_lines'];
    }

    /**
     * Sets invoice_lines
     *
     * @param \Swagger\Client\Model\InvoiceLine[] $invoice_lines An array of invoice lines.
     *
     * @return $this
     */
    public function setInvoiceLines($invoice_lines)
    {
        $this->container['invoice_lines'] = $invoice_lines;

        return $this;
    }

    /**
     * Gets accounting_cost
     *
     * @return string
     */
    public function getAccountingCost()
    {
        return $this->container['accounting_cost'];
    }

    /**
     * Sets accounting_cost
     *
     * @param string $accounting_cost The buyer's accounting cost centre for this invoice, expressed as text.
     *
     * @return $this
     */
    public function setAccountingCost($accounting_cost)
    {

        if (!is_null($accounting_cost) && (strlen($accounting_cost) < 1)) {
            throw new \InvalidArgumentException('invalid length for $accounting_cost when calling Invoice., must be bigger than or equal to 1.');
        }

        $this->container['accounting_cost'] = $accounting_cost;

        return $this;
    }

    /**
     * Gets accounting_cost_code
     *
     * @return \Swagger\Client\Model\AccountingCostCode
     */
    public function getAccountingCostCode()
    {
        return $this->container['accounting_cost_code'];
    }

    /**
     * Sets accounting_cost_code
     *
     * @param \Swagger\Client\Model\AccountingCostCode $accounting_cost_code accounting_cost_code
     *
     * @return $this
     */
    public function setAccountingCostCode($accounting_cost_code)
    {
        $this->container['accounting_cost_code'] = $accounting_cost_code;

        return $this;
    }

    /**
     * Gets due_date
     *
     * @return string
     */
    public function getDueDate()
    {
        return $this->container['due_date'];
    }

    /**
     * Sets due_date
     *
     * @param string $due_date Format: yyyy-mm-dd.
     *
     * @return $this
     */
    public function setDueDate($due_date)
    {

        if (!is_null($due_date) && (!preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/", $due_date))) {
            throw new \InvalidArgumentException("invalid value for $due_date when calling Invoice., must conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.");
        }

        $this->container['due_date'] = $due_date;

        return $this;
    }

    /**
     * Gets invoice_type
     *
     * @return string
     */
    public function getInvoiceType()
    {
        return $this->container['invoice_type'];
    }

    /**
     * Sets invoice_type
     *
     * @param string $invoice_type Use 380 for a regular invoice, 381 for a credit invoice, 384 for a corrective invoice. Note that invoiceType 381 must be for a positive amount! In case of invoiceType 384, the billingReference field must contain the invoiceNumber of the invoice being corrected.
     *
     * @return $this
     */
    public function setInvoiceType($invoice_type)
    {
        $allowedValues = $this->getInvoiceTypeAllowableValues();
        if (!is_null($invoice_type) && !in_array($invoice_type, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'invoice_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['invoice_type'] = $invoice_type;

        return $this;
    }

    /**
     * Gets tax_point_date
     *
     * @return string
     */
    public function getTaxPointDate()
    {
        return $this->container['tax_point_date'];
    }

    /**
     * Sets tax_point_date
     *
     * @param string $tax_point_date The tax date is the date on which the supply of goods or of services was made or completed or the date on which the payment on account was made insofar as that date can be determined and differs from the date of the issue of the invoice. EU 2006-112 Article 226 Point 7. Note: For the Dutch TAX authorities the tac date should be the same as the issue date.
     *
     * @return $this
     */
    public function setTaxPointDate($tax_point_date)
    {

        if (!is_null($tax_point_date) && (!preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/", $tax_point_date))) {
            throw new \InvalidArgumentException("invalid value for $tax_point_date when calling Invoice., must conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.");
        }

        $this->container['tax_point_date'] = $tax_point_date;

        return $this;
    }

    /**
     * Gets buyer_reference
     *
     * @return string
     */
    public function getBuyerReference()
    {
        return $this->container['buyer_reference'];
    }

    /**
     * Sets buyer_reference
     *
     * @param string $buyer_reference A reference provided by the buyer used for internal routing of the document.
     *
     * @return $this
     */
    public function setBuyerReference($buyer_reference)
    {
        $this->container['buyer_reference'] = $buyer_reference;

        return $this;
    }

    /**
     * Gets invoice_period
     *
     * @return string
     */
    public function getInvoicePeriod()
    {
        return $this->container['invoice_period'];
    }

    /**
     * Sets invoice_period
     *
     * @param string $invoice_period The period (or specific date) to which the invoice applies. Format: yyyy-mm-dd - yyyy-mm-dd.
     *
     * @return $this
     */
    public function setInvoicePeriod($invoice_period)
    {

        if (!is_null($invoice_period) && (!preg_match("/^[0-9]{4}-[0-9]{2}-[0-9]{2} - [0-9]{4}-[0-9]{2}-[0-9]{2}$/", $invoice_period))) {
            throw new \InvalidArgumentException("invalid value for $invoice_period when calling Invoice., must conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2} - [0-9]{4}-[0-9]{2}-[0-9]{2}$/.");
        }

        $this->container['invoice_period'] = $invoice_period;

        return $this;
    }

    /**
     * Gets order_reference
     *
     * @return string
     */
    public function getOrderReference()
    {
        return $this->container['order_reference'];
    }

    /**
     * Sets order_reference
     *
     * @param string $order_reference A reference to an order for this invoice, assigned by the buyer.
     *
     * @return $this
     */
    public function setOrderReference($order_reference)
    {
        $this->container['order_reference'] = $order_reference;

        return $this;
    }

    /**
     * Gets sales_order_id
     *
     * @return string
     */
    public function getSalesOrderId()
    {
        return $this->container['sales_order_id'];
    }

    /**
     * Sets sales_order_id
     *
     * @param string $sales_order_id A reference to an order for this invoice, assigned by the seller.
     *
     * @return $this
     */
    public function setSalesOrderId($sales_order_id)
    {
        $this->container['sales_order_id'] = $sales_order_id;

        return $this;
    }

    /**
     * Gets billing_reference
     *
     * @return string
     */
    public function getBillingReference()
    {
        return $this->container['billing_reference'];
    }

    /**
     * Sets billing_reference
     *
     * @param string $billing_reference A reference to a commercial invoice or corrective invoice of which the current invoice is a correction. This field is mandatory when sending invoiceType 384.
     *
     * @return $this
     */
    public function setBillingReference($billing_reference)
    {
        $this->container['billing_reference'] = $billing_reference;

        return $this;
    }

    /**
     * Gets contract_document_reference
     *
     * @return string
     */
    public function getContractDocumentReference()
    {
        return $this->container['contract_document_reference'];
    }

    /**
     * Sets contract_document_reference
     *
     * @param string $contract_document_reference A reference to a contract or framework agreement that this invoice relates to.
     *
     * @return $this
     */
    public function setContractDocumentReference($contract_document_reference)
    {
        $this->container['contract_document_reference'] = $contract_document_reference;

        return $this;
    }

    /**
     * Gets project_reference
     *
     * @return string
     */
    public function getProjectReference()
    {
        return $this->container['project_reference'];
    }

    /**
     * Sets project_reference
     *
     * @param string $project_reference Information about the project this invoice relates to.
     *
     * @return $this
     */
    public function setProjectReference($project_reference)
    {
        $this->container['project_reference'] = $project_reference;

        return $this;
    }

    /**
     * Gets payment_means_iban
     *
     * @return string
     */
    public function getPaymentMeansIban()
    {
        return $this->container['payment_means_iban'];
    }

    /**
     * Sets payment_means_iban
     *
     * @param string $payment_means_iban The IBAN the amount payable should be transferred to
     *
     * @return $this
     */
    public function setPaymentMeansIban($payment_means_iban)
    {
        $this->container['payment_means_iban'] = $payment_means_iban;

        return $this;
    }

    /**
     * Gets payment_means_code
     *
     * @return string
     */
    public function getPaymentMeansCode()
    {
        return $this->container['payment_means_code'];
    }

    /**
     * Sets payment_means_code
     *
     * @param string $payment_means_code Leave empty. Defaults to 31 if an IBAN is provided, otherwise defaults to 1. But leave empty.
     *
     * @return $this
     */
    public function setPaymentMeansCode($payment_means_code)
    {
        $this->container['payment_means_code'] = $payment_means_code;

        return $this;
    }

    /**
     * Gets payment_means_payment_id
     *
     * @return string
     */
    public function getPaymentMeansPaymentId()
    {
        return $this->container['payment_means_payment_id'];
    }

    /**
     * Sets payment_means_payment_id
     *
     * @param string $payment_means_payment_id The payment id that you will use to match the payment against the invoice.
     *
     * @return $this
     */
    public function setPaymentMeansPaymentId($payment_means_payment_id)
    {
        $this->container['payment_means_payment_id'] = $payment_means_payment_id;

        return $this;
    }

    /**
     * Gets amount_including_vat
     *
     * @return float
     */
    public function getAmountIncludingVat()
    {
        return $this->container['amount_including_vat'];
    }

    /**
     * Sets amount_including_vat
     *
     * @param float $amount_including_vat amountIncludingVat is important because of rounding differences. In many invoices, the sum of the line item amounts excluding VAT and the VAT amounts is not equal to first summing the line items without VAT, and then applying VAT. The difference is automatically calculated and included in the electronic invoice, so the receiving accounting package can process the electronic invoice without problems.
     *
     * @return $this
     */
    public function setAmountIncludingVat($amount_including_vat)
    {
        $this->container['amount_including_vat'] = $amount_including_vat;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


